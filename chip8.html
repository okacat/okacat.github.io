<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>okacat</title>
    <meta name="description" content="a personal webpage of Oskar Korošec">
    <meta name="author" content="Oskar Korošec">

    <link rel="stylesheet" href="resources/normalize.css">
    <link rel="stylesheet" href="resources/styles.css">
    <link rel="stylesheet" href="resources/font-styles.css">
</head>

<body>
    <header>
        <div id="logo"><a href="index.html">okacat</a></div>
    </header>

    <main class=article>
        <h1>CHIP-8 emulator</h1>

<a href="https://github.com/okacat/chip-8">Link to code on Github</a>

<p>
    Every now and then I get struck with a mood and an absolute need to program.
    Doesn't have to be solving anything or making anything creative. Just code.
    Making the CHIP-8 emulator was one of those times.
    Pick a solved problem and solve it again, just for the sake of it.
    This is also a great time to try a new language, and for writing an emulator it had to be Rust, I mean, it's only
    proper.
</p>

<figure>
    <img src="photos/chip8/chip8.png" />
    <figcaption>Running Tetris on the emulator</figcaption>
</figure>

<p>
    I've never written an emulator before, so this project definitely connected some dots in my head and shed some light
    on parts of the computer I don't often need to worry about.
    Even though I've read about those things in theory, actually coding it all from scratch gives a lot of insight and
    makes you realize the bits you're missing.
</p>

<p>
    Rust was a great choice for a low level project like an emulator.
    Just the way numbers are handled saved me a lot of time.
    Nothing is implicit when it comes to the type system.
    You want to add an 8 and a 16 bit number? Well which one is it? Better cast one of them first.
    Oh your addition overflowed? Here's an error, handle it.
    Got to love a good strict type system.
</p>

<p>
    Writing tests in Rust is easy too, they live in the same file as the code you're testing, very low effort to add a
    test for whatever function you're writing.
    Test driven development works extra well when your problem is as well defined as can be, like when implementing CPU
    instructions.
    You know exactly what each instruction needs to do, why not start with the test?
    Actually, having a full test coverage was key to getting the project finished.
    It's very frustrating to figure out which instructions are misbehaving when running a program if you don't have
    tests for them.
</p>

<p>
    All in all, great project to try.
    I need to tackle programming challenges just for the sake of it more often.
    Reinvent and make more wheels.
    Maybe GameBoy Color comes next.
    I already bought a second hand one, not to wade through tall grass, but for reasearch of course.
</p>
    </main>

    <footer>
        <div id="copyright">
            
            <span id="copyright">Oskar Korošec © 2025</span>
        </div>
    </footer>
</body>

</html>